package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"time"

	"github.com/unidoc/unipdf/v3/common/license"

	"github.com/unidoc/unipdf/v3/creator"
	"github.com/unidoc/unipdf/v3/model"
)

func init() {
	key := os.Getenv("UNIDOC_LICENSE_KEY")
	if key == "" {
		panic("UNIDOC_LICENSE_KEY not set in the current environment")
	}

	err := license.SetMeteredKey(key)
	if err != nil {
		fmt.Println("License already set")
	}

	// USING THIS LINE CAUSES A PANIC
	//
	// Commented 	-> Works
	// Uncommented 	-> Does Not Work
	license.SetMeteredKeyPersistentCache(false)
}

func main() {

	/////////////////////////////////
	// Read Input Data From JSON File
	/////////////////////////////////

	jsonData, err := ioutil.ReadFile("mock/data.json")
	if err != nil {
		fmt.Println("Error reading JSON file:", err)
		panic(err)
	}

	var pdfInputData PDFData
	err = json.Unmarshal(jsonData, &pdfInputData)
	if err != nil {
		fmt.Println("Error unmarshaling JSON:", err)
		panic(err)
	}

	////////////////////////////////////
	// Generate PDF File From Input Data
	////////////////////////////////////

	loc, err := time.LoadLocation("America/Chicago")
	if err != nil {
		fmt.Println("Error loading time zone:", err)
		panic(err)
	}
	currentTime := time.Now().In(loc)
	filepath := "/tmp/settlement.pdf"
	writePDF(filepath, pdfInputData, currentTime)
}

//////////////////
// DRAWING METHODS
//////////////////

// writePDF generates a settlement PDF document from input data
func writePDF(filepath string, data PDFData, currentTime time.Time) {

	////////////////
	// Define Assets
	////////////////

	fontRegular, err := model.NewPdfFontFromTTFFile("./assets/Roboto-Regular.ttf")
	if err != nil {
		panic(err)
	}
	fontBold, err := model.NewPdfFontFromTTFFile("./assets/Roboto-Bold.ttf")
	if err != nil {
		panic(err)
	}

	/////////////
	// Create PDF
	/////////////

	c := makeCreator()
	drawHeader(c, data, fontRegular, fontBold)
	drawFooter(c, data, currentTime, fontRegular, fontBold)
	drawFrontPage(c, data, fontRegular, fontBold)
	drawOtherPages(c, data, fontRegular, fontBold)

	////////////////
	// Write to File
	////////////////

	// THIS LINE CASUES A PANIC
	//
	// panic: error: Validation errors
	//
	err = c.WriteToFile(filepath)
	if err != nil {
		panic(err)
	}
}

func makeCreator() *creator.Creator {
	const PAGE_WIDTH float64 = 297
	const PAGE_HEIGHT float64 = 210
	const PAGE_MARGIN_LEFT float64 = 25
	const PAGE_MARGIN_RIGHT float64 = 25
	const PAGE_MARGIN_TOP float64 = 90
	const PAGE_MARGIN_BOTTOM float64 = 60

	c := creator.New()
	c.SetPageSize(creator.PageSize{PAGE_WIDTH * creator.PPMM, PAGE_HEIGHT * creator.PPMM})
	c.SetPageMargins(PAGE_MARGIN_LEFT, PAGE_MARGIN_RIGHT, PAGE_MARGIN_TOP, PAGE_MARGIN_BOTTOM)

	return c
}

func drawHeader(c *creator.Creator, data PDFData, fontRegular *model.PdfFont, fontBold *model.PdfFont) {
	c.DrawHeader(func(block *creator.Block, args creator.HeaderFunctionArgs) {

		//////////////////////////
		// Delta Grain Logo (Left)
		//////////////////////////

		logo, err := c.NewImageFromFile("./assets/logo.jpg")
		if err != nil {
			panic(err)
		}
		logo.ScaleToHeight(50)
		logo.SetPos(25, 25)
		block.Draw(logo)

		///////////////////////////
		// Ledger ID + Date (Right)
		///////////////////////////

		strPage := fmt.Sprintf("Ledger ID: %s", data.LedgerID)
		p := c.NewParagraph(strPage)
		p.SetFont(fontRegular)
		p.SetFontSize(8)
		p.SetPos(c.Context().PageWidth-p.Width()-25, 25)
		p.SetColor(creator.ColorRGBFrom8bit(63, 68, 76))
		block.Draw(p)

		strPage = fmt.Sprintf("Date: %s", data.LedgerDate)
		p = c.NewParagraph(strPage)
		p.SetFont(fontRegular)
		p.SetFontSize(8)
		p.SetPos(c.Context().PageWidth-p.Width()-25, 40)
		p.SetColor(creator.ColorRGBFrom8bit(63, 68, 76))
		block.Draw(p)
	})
}

func drawFooter(c *creator.Creator, data PDFData, currentTime time.Time, fontRegular *model.PdfFont, fontBold *model.PdfFont) {
	c.DrawFooter(func(block *creator.Block, args creator.FooterFunctionArgs) {

		/////////////////////////////
		// Delta Grain Company (Left)
		/////////////////////////////

		createdAt := currentTime.Format("01/02/2006 at 03:04:05 PM MST")
		auditString := fmt.Sprintf(
			"Generated by %s on %s",
			data.BusinessAddress.Name,
			createdAt,
		)
		p := c.NewParagraph(auditString)
		p.SetFont(fontRegular)
		p.SetFontSize(8)
		p.SetPos(25, 20)
		p.SetColor(creator.ColorRGBFrom8bit(169, 169, 169))
		block.Draw(p)

		/////////////////////
		// Page Index (Right)
		/////////////////////

		strPage := fmt.Sprintf("Page %d of %d", args.PageNum, args.TotalPages)
		p = c.NewParagraph(strPage)
		p.SetFont(fontRegular)
		p.SetFontSize(8)
		p.SetPos(c.Context().PageWidth-p.Width()-25, 20)
		p.SetColor(creator.ColorRGBFrom8bit(63, 68, 76))
		block.Draw(p)
	})
}

func drawFrontPage(c *creator.Creator, data PDFData, fontRegular *model.PdfFont, fontBold *model.PdfFont) {
	c.CreateFrontPage(func(args creator.FrontpageFunctionArgs) {

		///////////////////
		// Customer Address
		///////////////////

		p := c.NewParagraph("Customer:")
		p.SetFont(fontBold)
		p.SetFontSize(12)
		p.SetMargins(0, 0, 40, 0)
		p.SetTextAlignment(creator.TextAlignmentCenter)
		p.SetColor(creator.ColorRGBFrom8bit(56, 68, 77))
		c.Draw(p)

		str := data.CustomerAddress.Name
		str += fmt.Sprintf("\n%s", data.CustomerAddress.Address1)
		str += fmt.Sprintf("\n%s, %s %s", data.CustomerAddress.City, data.CustomerAddress.State, data.CustomerAddress.Zip)
		p = c.NewParagraph(str)
		p.SetFont(fontRegular)
		p.SetFontSize(12)
		p.SetMargins(0, 0, 5, 0)
		p.SetTextAlignment(creator.TextAlignmentCenter)
		p.SetColor(creator.ColorRGBFrom8bit(56, 68, 77))
		c.Draw(p)

		//////////////////////
		// Delta Grain Address
		//////////////////////

		p = c.NewParagraph("Settled With:")
		p.SetFont(fontBold)
		p.SetFontSize(12)
		p.SetMargins(0, 0, 40, 0)
		p.SetTextAlignment(creator.TextAlignmentCenter)
		p.SetColor(creator.ColorRGBFrom8bit(56, 68, 77))
		c.Draw(p)

		str = data.BusinessAddress.Name
		str += fmt.Sprintf("\n%s", data.BusinessAddress.Address1)
		str += fmt.Sprintf("\n%s, %s %s", data.BusinessAddress.City, data.BusinessAddress.State, data.BusinessAddress.Zip)
		str += fmt.Sprintf("\nPhone: %s", data.BusinessAddress.Phone)
		p = c.NewParagraph(str)
		p.SetFont(fontRegular)
		p.SetFontSize(12)
		p.SetMargins(0, 0, 5, 0)
		p.SetTextAlignment(creator.TextAlignmentCenter)
		p.SetColor(creator.ColorRGBFrom8bit(56, 68, 77))
		c.Draw(p)

		/////////////////
		// Contract Table
		/////////////////

		pColor := creator.ColorRGBFrom8bit(72, 86, 95)
		bgColor := creator.ColorRGBFrom8bit(56, 68, 67)

		const COVER_TABLE_COLUMN_COUNT float64 = 4
		coverTable := c.NewTable(int(COVER_TABLE_COLUMN_COUNT))

		// - Define Cover Table Headers

		coverTableCols := []string{
			"Contract ID",
			"Commodity",
			"Applied Bushels",
			"$ Amount",
		}

		for _, col := range coverTableCols {
			p := c.NewParagraph(col)
			p.SetFont(fontBold)
			p.SetFontSize(7)
			p.SetColor(creator.ColorWhite)
			p.SetMargins(0, 0, 1, 2)
			cell := coverTable.NewCell()
			cell.SetBackgroundColor(bgColor)
			cell.SetBorder(creator.CellBorderSideAll, creator.CellBorderStyleSingle, 1)
			cell.SetHorizontalAlignment(creator.CellHorizontalAlignmentCenter)
			cell.SetVerticalAlignment(creator.CellVerticalAlignmentMiddle)
			cell.SetContent(p)
		}

		// - Define Cover Table Row

		numPages := make([]int, len(data.Pages))
		for i := range numPages {
			coverTableVals := []string{
				data.Pages[i].Contract.ID,
				data.Pages[i].Contract.Commodity,
				data.Pages[i].Contract.AppliedNow,
				data.Pages[i].Contract.TotalAmount,
			}

			coverTableCellAlignmentGuide := []creator.CellHorizontalAlignment{
				2, 1, 2, 2,
			}
			for i, val := range coverTableVals {
				p := c.NewParagraph(val)
				p.SetFont(fontRegular)
				p.SetFontSize(7)
				p.SetColor(pColor)
				p.SetMargins(0, 0, 1, 2)
				cell := coverTable.NewCell()
				cell.SetBorder(creator.CellBorderSideAll, creator.CellBorderStyleSingle, 1)
				cell.SetHorizontalAlignment(coverTableCellAlignmentGuide[i])
				cell.SetVerticalAlignment(creator.CellVerticalAlignmentMiddle)
				cell.SetContent(p)
			}
		}

		// - Define Cover Table Summary Row

		coverTableSummaryVals := []string{
			"",
			"",
			"",
			data.TotalAmount,
		}

		coverTableCellAlignmentGuide := []creator.CellHorizontalAlignment{
			2, 1, 2, 2,
		}
		for i, val := range coverTableSummaryVals {
			p := c.NewParagraph(val)
			p.SetFont(fontBold)
			p.SetFontSize(7)
			p.SetColor(pColor)
			p.SetMargins(0, 0, 1, 2)
			cell := coverTable.NewCell()
			if i == len(coverTableSummaryVals)-1 {
				cell.SetBorder(creator.CellBorderSideAll, creator.CellBorderStyleSingle, 1)
			}
			cell.SetHorizontalAlignment(coverTableCellAlignmentGuide[i])
			cell.SetVerticalAlignment(creator.CellVerticalAlignmentMiddle)
			cell.SetContent(p)
		}

		// - Define Cover Table Placement

		coverTable.SetMargins(250, 250, 40, 0)
		coverTable.SetColumnWidths(
			1/COVER_TABLE_COLUMN_COUNT,
			1/COVER_TABLE_COLUMN_COUNT,
			1/COVER_TABLE_COLUMN_COUNT,
			1/COVER_TABLE_COLUMN_COUNT,
		)

		// - Draw Cover Table

		err := c.Draw(coverTable)
		if err != nil {
			panic(err)
		}
	})
}

func drawOtherPages(c *creator.Creator, data PDFData, fontRegular *model.PdfFont, fontBold *model.PdfFont) {
	pColor := creator.ColorRGBFrom8bit(72, 86, 95)
	bgColor := creator.ColorRGBFrom8bit(56, 68, 67)

	////////////////////////////////////////////
	// Create New Page For Each Settled Contract
	////////////////////////////////////////////

	numSections := make([]int, len(data.Pages))
	for i := range numSections {
		c.NewPage()

		////////////////////////
		// Contract Table Header
		////////////////////////

		tableHeaderLabel := fmt.Sprintf("%s - Contracts Settled", data.CustomerAddress.Name)
		p := c.NewParagraph(tableHeaderLabel)
		p.SetFont(fontBold)
		p.SetFontSize(10)
		p.SetMargins(0, 0, 0, 0)
		p.SetColor(creator.ColorRGBFrom8bit(77, 166, 255))
		c.Draw(p)

		/////////////////
		// Contract Table
		/////////////////

		const CONTRACT_TABLE_COLUMN_COUNT float64 = 14
		contractTable := c.NewTable(int(CONTRACT_TABLE_COLUMN_COUNT))

		// - Define Contract Table Headers

		contractTableCols := []string{
			"Contract ID",
			"Date",
			"Commodity",
			"Buy/Sell",
			"Delivery Date",
			"CBOT Price",
			"Basis",
			"Adjustment",
			"Net",
			"Quantity",
			"Applied Now",
			"Applied to Date",
			"Left to Fill",
			"Total Amount",
		}

		for _, col := range contractTableCols {
			p := c.NewParagraph(col)
			p.SetFont(fontBold)
			p.SetFontSize(7)
			p.SetColor(creator.ColorWhite)
			p.SetMargins(0, 0, 1, 2)
			cell := contractTable.NewCell()
			cell.SetBackgroundColor(bgColor)
			cell.SetBorder(creator.CellBorderSideAll, creator.CellBorderStyleSingle, 1)
			cell.SetHorizontalAlignment(creator.CellHorizontalAlignmentCenter)
			cell.SetVerticalAlignment(creator.CellVerticalAlignmentMiddle)
			cell.SetContent(p)
		}

		// - Define Contract Table Row

		contractTableVals := []string{
			data.Pages[i].Contract.ID,
			data.Pages[i].Contract.Date,
			data.Pages[i].Contract.Commodity,
			data.Pages[i].Contract.BuySell,
			data.Pages[i].Contract.DeliveryDate,
			data.Pages[i].Contract.CBOTPrice,
			data.Pages[i].Contract.Basis,
			data.Pages[i].Contract.Adjustment,
			data.Pages[i].Contract.Net,
			data.Pages[i].Contract.Quantity,
			data.Pages[i].Contract.AppliedNow,
			data.Pages[i].Contract.AppliedToDate,
			data.Pages[i].Contract.LeftToFill,
			data.Pages[i].Contract.TotalAmount,
		}

		contractTableCellAlignmentGuide := []creator.CellHorizontalAlignment{
			2, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		}
		for i, val := range contractTableVals {
			p := c.NewParagraph(val)
			p.SetFont(fontRegular)
			p.SetFontSize(7)
			p.SetColor(pColor)
			p.SetMargins(0, 0, 1, 2)
			cell := contractTable.NewCell()
			cell.SetBorder(creator.CellBorderSideAll, creator.CellBorderStyleSingle, 1)
			cell.SetHorizontalAlignment(contractTableCellAlignmentGuide[i])
			cell.SetVerticalAlignment(creator.CellVerticalAlignmentMiddle)
			cell.SetContent(p)
		}

		// - Define Contract Table Placement

		contractTable.SetMargins(0, 0, 10, 0)
		contractTable.SetColumnWidths(
			1/CONTRACT_TABLE_COLUMN_COUNT,
			1/CONTRACT_TABLE_COLUMN_COUNT,
			1/CONTRACT_TABLE_COLUMN_COUNT,
			1/CONTRACT_TABLE_COLUMN_COUNT,
			1/CONTRACT_TABLE_COLUMN_COUNT,
			1/CONTRACT_TABLE_COLUMN_COUNT,
			1/CONTRACT_TABLE_COLUMN_COUNT,
			1/CONTRACT_TABLE_COLUMN_COUNT,
			1/CONTRACT_TABLE_COLUMN_COUNT,
			1/CONTRACT_TABLE_COLUMN_COUNT,
			1/CONTRACT_TABLE_COLUMN_COUNT,
			1/CONTRACT_TABLE_COLUMN_COUNT,
			1/CONTRACT_TABLE_COLUMN_COUNT,
			1/CONTRACT_TABLE_COLUMN_COUNT,
		)

		// - Draw Contract Table

		err := c.Draw(contractTable)
		if err != nil {
			panic(err)
		}

		//////////////////////
		// Scale Tickets Table
		//////////////////////

		tableHeaderLabel = "Scale tickets used in this settlement"
		p = c.NewParagraph(tableHeaderLabel)
		p.SetFont(fontBold)
		p.SetFontSize(10)
		p.SetMargins(0, 0, 20, 0)
		p.SetColor(creator.ColorRGBFrom8bit(77, 166, 255))
		c.Draw(p)

		/////////////////////////////
		// Scale Tickets Table Header
		/////////////////////////////

		const SCALE_TICKETS_TABLE_COLUMN_COUNT float64 = 15
		scaleTicketsTable := c.NewTable(int(SCALE_TICKETS_TABLE_COLUMN_COUNT))

		// - Define Scale Tickets Table Headers

		scaleTicketsTableCols := []string{
			"Date",
			"ID",
			"Commodity",
			"Farm #",
			"DestTicket #",
			"Gross (bu)",
			"T.W.",
			"Moist",
			"FM",
			"Weight Adjustments",
			"Net (bu)",
			"Applied to Contract (bu)",
			"Price Adjustments",
			"Check Off",
			"Amount",
		}

		for _, col := range scaleTicketsTableCols {
			p := c.NewParagraph(col)
			p.SetFont(fontBold)
			p.SetFontSize(7)
			p.SetColor(creator.ColorWhite)
			p.SetMargins(0, 0, 1, 2)
			cell := scaleTicketsTable.NewCell()
			cell.SetBackgroundColor(bgColor)
			cell.SetBorder(creator.CellBorderSideAll, creator.CellBorderStyleSingle, 1)
			cell.SetHorizontalAlignment(creator.CellHorizontalAlignmentCenter)
			cell.SetVerticalAlignment(creator.CellVerticalAlignmentMiddle)
			cell.SetContent(p)
		}

		// - Define Scale Tickets Table Rows

		numScaleTickets := make([]int, len(data.Pages[i].ScaleTickets))
		for j := range numScaleTickets {
			scaleTicketsTableVals := []string{
				data.Pages[i].ScaleTickets[j].Date,
				data.Pages[i].ScaleTickets[j].ID,
				data.Pages[i].ScaleTickets[j].Commodity,
				data.Pages[i].ScaleTickets[j].FarmNumber,
				data.Pages[i].ScaleTickets[j].DestinationTicketNumber,
				data.Pages[i].ScaleTickets[j].GrossBushels,
				data.Pages[i].ScaleTickets[j].TestWeight,
				data.Pages[i].ScaleTickets[j].Moisture,
				data.Pages[i].ScaleTickets[j].FM,
				data.Pages[i].ScaleTickets[j].WeightAdjustments,
				data.Pages[i].ScaleTickets[j].NetBushels,
				data.Pages[i].ScaleTickets[j].AppliedBushels,
				data.Pages[i].ScaleTickets[j].PriceAdjustments,
				data.Pages[i].ScaleTickets[j].CheckOff,
				data.Pages[i].ScaleTickets[j].Amount,
			}

			scaleTicketsTableCellAlignmentGuide := []creator.CellHorizontalAlignment{
				1, 1, 1, 2, 1, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2,
			}
			for i, val := range scaleTicketsTableVals {
				p := c.NewParagraph(val)
				p.SetFont(fontRegular)
				p.SetFontSize(7)
				p.SetColor(pColor)
				p.SetMargins(0, 0, 1, 2)
				cell := scaleTicketsTable.NewCell()
				cell.SetBorder(creator.CellBorderSideAll, creator.CellBorderStyleSingle, 1)
				cell.SetHorizontalAlignment(scaleTicketsTableCellAlignmentGuide[i])
				cell.SetVerticalAlignment(creator.CellVerticalAlignmentMiddle)
				cell.SetContent(p)
			}
		}

		// - Define Scale Tickets Table Placement

		scaleTicketsTable.SetMargins(0, 0, 10, 0)
		contractTable.SetColumnWidths(
			1/SCALE_TICKETS_TABLE_COLUMN_COUNT,
			1/SCALE_TICKETS_TABLE_COLUMN_COUNT,
			1/SCALE_TICKETS_TABLE_COLUMN_COUNT,
			1/SCALE_TICKETS_TABLE_COLUMN_COUNT,
			1/SCALE_TICKETS_TABLE_COLUMN_COUNT,
			1/SCALE_TICKETS_TABLE_COLUMN_COUNT,
			1/SCALE_TICKETS_TABLE_COLUMN_COUNT,
			1/SCALE_TICKETS_TABLE_COLUMN_COUNT,
			1/SCALE_TICKETS_TABLE_COLUMN_COUNT,
			1/SCALE_TICKETS_TABLE_COLUMN_COUNT,
			1/SCALE_TICKETS_TABLE_COLUMN_COUNT,
			1/SCALE_TICKETS_TABLE_COLUMN_COUNT,
			1/SCALE_TICKETS_TABLE_COLUMN_COUNT,
			1/SCALE_TICKETS_TABLE_COLUMN_COUNT,
		)

		// - Draw Scale Tickets Table

		err = c.Draw(scaleTicketsTable)
		if err != nil {
			panic(err)
		}
	}
}

/////////
// MODELS
/////////

// PDFData is a data structure that contains all the required information for generating
// a PDF document for a ledger entry
type PDFData struct {
	LedgerID        string
	LedgerDate      string
	BusinessAddress address
	CustomerAddress address
	Pages           []page
	TotalAmount     string
}

type address struct {
	Name     string
	Address1 string
	Address2 string
	City     string
	State    string
	Zip      string
	Phone    string
}

type page struct {
	Contract     contract
	ScaleTickets []scaleticket
}

type contract struct {
	ID            string
	Date          string
	Commodity     string
	BuySell       string
	DeliveryDate  string
	CBOTPrice     string
	Basis         string
	Adjustment    string
	Net           string
	Quantity      string
	AppliedNow    string
	AppliedToDate string
	LeftToFill    string
	TotalAmount   string
}

type scaleticket struct {
	Date                    string
	ID                      string
	Commodity               string
	FarmNumber              string
	DestinationTicketNumber string
	GrossBushels            string
	TestWeight              string
	Moisture                string
	FM                      string
	WeightAdjustments       string
	NetBushels              string
	AppliedBushels          string
	PriceAdjustments        string
	CheckOff                string
	Amount                  string
}
